{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AFX Concepts # AFX is a command-line package manager. afx can allow us to manage almost all things available on GitHub, Gist and so on. Before, we nee ded to trawl web pages to download each package one by one. It's very annoying every time we set up new machine and also it's difficult to get how many commands/plugins we installed. So afx's motivation is coming from that and to manage them with YAML files (as a code). Package manager for everything Usage: afx [command] Available Commands: help Help about any command init Initialize installed packages install Resume installation from paused part (idempotency) uninstall Uninstall installed packages update Update installed repository if needed Flags: -h, --help help for afx Use \"afx [command] --help\" for more information about a command.","title":"Home"},{"location":"#afx-concepts","text":"AFX is a command-line package manager. afx can allow us to manage almost all things available on GitHub, Gist and so on. Before, we nee ded to trawl web pages to download each package one by one. It's very annoying every time we set up new machine and also it's difficult to get how many commands/plugins we installed. So afx's motivation is coming from that and to manage them with YAML files (as a code). Package manager for everything Usage: afx [command] Available Commands: help Help about any command init Initialize installed packages install Resume installation from paused part (idempotency) uninstall Uninstall installed packages update Update installed repository if needed Flags: -h, --help help for afx Use \"afx [command] --help\" for more information about a command.","title":"AFX Concepts"},{"location":"getting-started/","text":"Getting Started # Install the pre-compiled binary # You can install the pre-compiled binary (in several different ways), compile from source. Below you can find the steps for each of them. go install # $ go install github.com/b4b4r07/afx@latest manually # Download the pre-compiled binaries from the OSS releases page and copy them to the desired location. Write YAML # Let's say you want to install jq and enhancd with afx. So please write YAML file like this: github : - name : jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq - name : enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh This declaration means afx gets jq v1.6 from GitHub release and install it into PATH as a command. Okay, then let's save this file in ~/.config/afx/main.yaml . Install packages # After preparing YAML files, you become able to run install command: $ afx install This command runs install based on what were declared in YAML files. Initialize packages # After installed, you need to run this command to enable commands/plugins you installed. $ source < ( afx init ) afx init is just showing what needed to run commands/plugins. As a test, try to run. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" As long as you don't run it with source command, it doesn't effect your current shell. Initialize when starting shell # Add this command to your shell config (e.g. .zshrc) enable plugins and commands you installed when starting shell. # enable packages source < ( afx init ) Update packages # If you want to update package to new version etc, all you have to do is just to modify YAML file and then run afx update : github: - name: jq description: Command-line JSON processor owner: stedolan repo: jq release: name: jq - tag: jq-1.5 + tag: jq-1.6 command: link: - from: '*jq*' to: jq $ afx update \u2714 jq","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#install-the-pre-compiled-binary","text":"You can install the pre-compiled binary (in several different ways), compile from source. Below you can find the steps for each of them.","title":"Install the pre-compiled binary"},{"location":"getting-started/#go-install","text":"$ go install github.com/b4b4r07/afx@latest","title":"go install"},{"location":"getting-started/#manually","text":"Download the pre-compiled binaries from the OSS releases page and copy them to the desired location.","title":"manually"},{"location":"getting-started/#write-yaml","text":"Let's say you want to install jq and enhancd with afx. So please write YAML file like this: github : - name : jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq - name : enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh This declaration means afx gets jq v1.6 from GitHub release and install it into PATH as a command. Okay, then let's save this file in ~/.config/afx/main.yaml .","title":"Write YAML"},{"location":"getting-started/#install-packages","text":"After preparing YAML files, you become able to run install command: $ afx install This command runs install based on what were declared in YAML files.","title":"Install packages"},{"location":"getting-started/#initialize-packages","text":"After installed, you need to run this command to enable commands/plugins you installed. $ source < ( afx init ) afx init is just showing what needed to run commands/plugins. As a test, try to run. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" As long as you don't run it with source command, it doesn't effect your current shell.","title":"Initialize packages"},{"location":"getting-started/#initialize-when-starting-shell","text":"Add this command to your shell config (e.g. .zshrc) enable plugins and commands you installed when starting shell. # enable packages source < ( afx init )","title":"Initialize when starting shell"},{"location":"getting-started/#update-packages","text":"If you want to update package to new version etc, all you have to do is just to modify YAML file and then run afx update : github: - name: jq description: Command-line JSON processor owner: stedolan repo: jq release: name: jq - tag: jq-1.5 + tag: jq-1.6 command: link: - from: '*jq*' to: jq $ afx update \u2714 jq","title":"Update packages"},{"location":"how-it-works/","text":"How it works # Where to put YAML # Example of config directory structure. In afx, all installation declaration can be kept in YAML files. All configurations should be basically saved in $AFX_CONFIG_PATH . It defaults to ~/.config/afx . You can create YAML files that your package declarations are described and save them in this config directory. In AFX_CONFIG_PATH, you can keep files with these rules: Naming files as you like is ok Having single file can be ok Deviding into multiple files is also ok Creating sub dir can be also ok Let's describe each one below. Single file # You can create files with any name you like. In above case, declaration of GitHub packages are saved in github.yaml and packages of GitHub Releases are saved in release.yaml . Others (e.g. local etc) are saved in main.yaml . ~/.config/afx \u2514\u2500\u2500 afx.yaml It's ok to keep them in one single file. You can choose which one to suit your style. Multiple files # You can divide them into each files to make file name and its contents clear and also put it into one YAML file. ~/.config/afx \u251c\u2500\u2500 github.yaml \u251c\u2500\u2500 main.yaml \u2514\u2500\u2500 release.yaml Sub directories # Keeping files in sub directories is also ok. afx tries to walk all directories and find files ending with .yaml or .yml . ~/.config/afx \u251c\u2500\u2500 subdir \u2502 \u251c\u2500\u2500 github-1.yaml \u2502 \u2514\u2500\u2500 github-2.yaml \u251c\u2500\u2500 local.yaml \u2514\u2500\u2500 http.yaml State feature # Example of a state file. afx have a state feature like Terraform . In afx, due to this state feature, what was written in the YAML files means always packages list of what a user desired to install. In short, adding a package declaration to YAML files is to install them to your system and also deleting a package declaration from YAML files is to uninstall from your system. State in afx All of package declarations are saved in the state file. Install and uninstall will be run by using the difference between YAML files and records in the state file Install Uninstall github: - name: enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh + - name: fzy + description: A better fuzzy finder + owner: jhawthorn + repo: fzy + command: + build: + steps: + - make + - sudo make install After adding package declaration to your YAML, then run this command: $ afx install github: - name: enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh - - name: fzy - description: A better fuzzy finder - owner: jhawthorn - repo: fzy - command: - build: - steps: - - make - - sudo make install After deleting package declaration from your YAML, then run this command: $ afx uninstall Localtion of a state file Location of state file defaults to ~/.afx/state.json . Currently afx does not provide the way to change this path and basically user should not touch this file because it's used internally by afx to keep equivalence between YAML files and its state file. It's likely to be happened unexpected install/uninstall by changing a state file. Installation # Workflow to install packages. Initialize your commands/plugins # After installed, basically you need to run afx init command and run source command with the output of that command in order to become able to use commands and plugins you installed. $ source < ( afx init ) This is just an example of afx init . Running source command with this output means these statements are evaluate in current shell. So we can use plugins in current shell and also aliases, variables and so on. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" source /Users/babarot/.afx/github.com/zdharma-continuum/history-search-multi-word/history-search-multi-word.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-vimode-visual/zsh-vimode-visual.zsh alias diff = \"colordiff -u\" source /Users/babarot/.afx/github.com/zdharma-continuum/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-prompt-minimal/minimal.zsh-theme export PROMPT_PATH_STYLE = \"minimal\" export PROMPT_USE_VIM_MODE = \"true\" ## package shlide is not installed, so skip to init source /Users/babarot/.zsh/10_utils.zsh source /Users/babarot/.zsh/20_keybinds.zsh source /Users/babarot/.zsh/30_aliases.zsh source /Users/babarot/.zsh/50_setopt.zsh source /Users/babarot/.zsh/70_misc.zsh afx initialize step just only generates these statements based on your YAML files.","title":"How it works"},{"location":"how-it-works/#how-it-works","text":"","title":"How it works"},{"location":"how-it-works/#where-to-put-yaml","text":"Example of config directory structure. In afx, all installation declaration can be kept in YAML files. All configurations should be basically saved in $AFX_CONFIG_PATH . It defaults to ~/.config/afx . You can create YAML files that your package declarations are described and save them in this config directory. In AFX_CONFIG_PATH, you can keep files with these rules: Naming files as you like is ok Having single file can be ok Deviding into multiple files is also ok Creating sub dir can be also ok Let's describe each one below.","title":"Where to put YAML"},{"location":"how-it-works/#single-file","text":"You can create files with any name you like. In above case, declaration of GitHub packages are saved in github.yaml and packages of GitHub Releases are saved in release.yaml . Others (e.g. local etc) are saved in main.yaml . ~/.config/afx \u2514\u2500\u2500 afx.yaml It's ok to keep them in one single file. You can choose which one to suit your style.","title":"Single file"},{"location":"how-it-works/#multiple-files","text":"You can divide them into each files to make file name and its contents clear and also put it into one YAML file. ~/.config/afx \u251c\u2500\u2500 github.yaml \u251c\u2500\u2500 main.yaml \u2514\u2500\u2500 release.yaml","title":"Multiple files"},{"location":"how-it-works/#sub-directories","text":"Keeping files in sub directories is also ok. afx tries to walk all directories and find files ending with .yaml or .yml . ~/.config/afx \u251c\u2500\u2500 subdir \u2502 \u251c\u2500\u2500 github-1.yaml \u2502 \u2514\u2500\u2500 github-2.yaml \u251c\u2500\u2500 local.yaml \u2514\u2500\u2500 http.yaml","title":"Sub directories"},{"location":"how-it-works/#state-feature","text":"Example of a state file. afx have a state feature like Terraform . In afx, due to this state feature, what was written in the YAML files means always packages list of what a user desired to install. In short, adding a package declaration to YAML files is to install them to your system and also deleting a package declaration from YAML files is to uninstall from your system. State in afx All of package declarations are saved in the state file. Install and uninstall will be run by using the difference between YAML files and records in the state file Install Uninstall github: - name: enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh + - name: fzy + description: A better fuzzy finder + owner: jhawthorn + repo: fzy + command: + build: + steps: + - make + - sudo make install After adding package declaration to your YAML, then run this command: $ afx install github: - name: enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh - - name: fzy - description: A better fuzzy finder - owner: jhawthorn - repo: fzy - command: - build: - steps: - - make - - sudo make install After deleting package declaration from your YAML, then run this command: $ afx uninstall Localtion of a state file Location of state file defaults to ~/.afx/state.json . Currently afx does not provide the way to change this path and basically user should not touch this file because it's used internally by afx to keep equivalence between YAML files and its state file. It's likely to be happened unexpected install/uninstall by changing a state file.","title":"State feature"},{"location":"how-it-works/#installation","text":"Workflow to install packages.","title":"Installation"},{"location":"how-it-works/#initialize-your-commandsplugins","text":"After installed, basically you need to run afx init command and run source command with the output of that command in order to become able to use commands and plugins you installed. $ source < ( afx init ) This is just an example of afx init . Running source command with this output means these statements are evaluate in current shell. So we can use plugins in current shell and also aliases, variables and so on. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" source /Users/babarot/.afx/github.com/zdharma-continuum/history-search-multi-word/history-search-multi-word.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-vimode-visual/zsh-vimode-visual.zsh alias diff = \"colordiff -u\" source /Users/babarot/.afx/github.com/zdharma-continuum/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-prompt-minimal/minimal.zsh-theme export PROMPT_PATH_STYLE = \"minimal\" export PROMPT_USE_VIM_MODE = \"true\" ## package shlide is not installed, so skip to init source /Users/babarot/.zsh/10_utils.zsh source /Users/babarot/.zsh/20_keybinds.zsh source /Users/babarot/.zsh/30_aliases.zsh source /Users/babarot/.zsh/50_setopt.zsh source /Users/babarot/.zsh/70_misc.zsh afx initialize step just only generates these statements based on your YAML files.","title":"Initialize your commands/plugins"},{"location":"links/","text":"Links # Examples on afx config: b4b4r07/dotfiles Similar projects: zplug/zplug","title":"Links"},{"location":"links/#links","text":"Examples on afx config: b4b4r07/dotfiles Similar projects: zplug/zplug","title":"Links"},{"location":"configuration/command/","text":"Command # afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources. Parameters # build.steps # Type Required list yes (when using build ) build.steps can be specified build commands to build a package. Case 1 Case 2 Using sudo github : - name : fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install In this case, build steps has sudo command but it can be run as expected. But in advance you will be asked to input sudo password. Using go build github : - name : kubectl-trace description : Schedule bpftrace programs on your kubernetes cluster using the kubectl owner : iovisor repo : kubectl-trace command : build : steps : - go build -o kubectl-trace cmd/kubectl-trace/root.go link : - from : kubectl-trace to : kubectl-trace In this case, build steps run go build command because this package does not provide GitHub releases on its own page. So we need to build by ourselves. afx build feature is very helpful in such a case. go build command creates red command to current working directory so you need to have link section to install the built binary to your PATH. build.env # Type Required map no build.env can be specified environemnt variables used when running build a package. Case 1 github : - name : fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install env : VERSION : 1.0 In this case, VERSION is specified to change version used in build steps. link.from # Type Required string yes (when using link ) link.from can be specified where to install from. Case 1 Case 2 Just install from current directory github : - name : diff-so-fancy description : Good-lookin' diffs. Actually\u2026 nah\u2026 The best-lookin' diffs. owner : so-fancy repo : diff-so-fancy command : link : - from : diff-so-fancy To specify where to install from, just need to fill in link.from . Case of including version string etc in file name github : - name : jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq This link.from field is based on downloaded package directory. If the binary name has unneeded string and it's difficult to find a binary with fixed string. In that case, you can use wildcard in from field. link.to # Type Required string no link.to can be specified where to install to. Case 1 Case 2 Case 3 Simple case, with renaming by using `to` field github : - name : prok description : easy process grep with ps output owner : mutantcornholio repo : prok command : link : - from : prok.sh to : prok By filling in link.to field, you can specify where to install to. This field can be omitted but in that case it will be regarded as same thing of link.from value. In short, you don't need to fill in this field if you don't need to rename link.from to new one while linking. If you want to rename command name from link.from to new one, you can use this field like above example (this prok.sh will be renamed to prok and then install it into PATH) from current working dir to external dir of afx github : - name : tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm This example shows you to link all contents in current working directory to ~/.tmux/plugins/tpm directory. You can use outside directory of afx in link.to field, but in that case you need to specify full path. Using tilda ~ is also ok to specify $HOME . Several links github : - name : kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns link section is a list, so you can specify several pairs of from and to . env # Type Required map no env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat' alias # Type Required map no alias allows you to set command aliases. Case 1 Case 2 Case 3 github : - name : colordiff description : Primary development for colordiff owner : daveewart repo : colordiff command : alias : diff : colordiff -u link : - from : colordiff.pl to : colordiff github : - name : exa description : A modern version of 'ls'. owner : ogham repo : exa release : name : exa tag : v0.9.0 command : alias : l : exa --group-directories-first -T --git-ignore --level 2 la : exa --group-directories-first -a --header --git ll : exa --group-directories-first -l --header --git lla : exa --group-directories-first -la --header --git ls : exa --group-directories-first link : - from : '*exa*' to : exa github : - name : bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat' snippet # Type Required string no snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm snippet : | echo \"tpm is installed, so tmux will be automatically launched\" echo \"see github.com/tmux-plugins/tpm\" if # Type Required string no if allows you to specify the condition to load packages. If it returns true, then the command will be linked. But if it returns false, the command will not be linked. In if field, you can write shell scripts (currently bash is only supported). The exit code finally returned from that shell script is used to determine whether it links command or not. Case 1 link commands if git is installed github : - name : chmln/sd description : Intuitive find & replace CLI (sed alternative) owner : chmln repo : sd release : name : sd tag : 0.6.5 command : if : | type git &>/dev/null snippet : | replace() { case \"${#}\" in 1) git grep \"${1}\" ;; 2) git grep -l \"${1}\" | xargs -I% sd \"${1}\" \"${2}\" % ;; esac }","title":"Command"},{"location":"configuration/command/#command","text":"afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources.","title":"Command"},{"location":"configuration/command/#parameters","text":"","title":"Parameters"},{"location":"configuration/command/#buildsteps","text":"Type Required list yes (when using build ) build.steps can be specified build commands to build a package. Case 1 Case 2 Using sudo github : - name : fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install In this case, build steps has sudo command but it can be run as expected. But in advance you will be asked to input sudo password. Using go build github : - name : kubectl-trace description : Schedule bpftrace programs on your kubernetes cluster using the kubectl owner : iovisor repo : kubectl-trace command : build : steps : - go build -o kubectl-trace cmd/kubectl-trace/root.go link : - from : kubectl-trace to : kubectl-trace In this case, build steps run go build command because this package does not provide GitHub releases on its own page. So we need to build by ourselves. afx build feature is very helpful in such a case. go build command creates red command to current working directory so you need to have link section to install the built binary to your PATH.","title":"build.steps"},{"location":"configuration/command/#buildenv","text":"Type Required map no build.env can be specified environemnt variables used when running build a package. Case 1 github : - name : fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install env : VERSION : 1.0 In this case, VERSION is specified to change version used in build steps.","title":"build.env"},{"location":"configuration/command/#linkfrom","text":"Type Required string yes (when using link ) link.from can be specified where to install from. Case 1 Case 2 Just install from current directory github : - name : diff-so-fancy description : Good-lookin' diffs. Actually\u2026 nah\u2026 The best-lookin' diffs. owner : so-fancy repo : diff-so-fancy command : link : - from : diff-so-fancy To specify where to install from, just need to fill in link.from . Case of including version string etc in file name github : - name : jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq This link.from field is based on downloaded package directory. If the binary name has unneeded string and it's difficult to find a binary with fixed string. In that case, you can use wildcard in from field.","title":"link.from"},{"location":"configuration/command/#linkto","text":"Type Required string no link.to can be specified where to install to. Case 1 Case 2 Case 3 Simple case, with renaming by using `to` field github : - name : prok description : easy process grep with ps output owner : mutantcornholio repo : prok command : link : - from : prok.sh to : prok By filling in link.to field, you can specify where to install to. This field can be omitted but in that case it will be regarded as same thing of link.from value. In short, you don't need to fill in this field if you don't need to rename link.from to new one while linking. If you want to rename command name from link.from to new one, you can use this field like above example (this prok.sh will be renamed to prok and then install it into PATH) from current working dir to external dir of afx github : - name : tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm This example shows you to link all contents in current working directory to ~/.tmux/plugins/tpm directory. You can use outside directory of afx in link.to field, but in that case you need to specify full path. Using tilda ~ is also ok to specify $HOME . Several links github : - name : kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns link section is a list, so you can specify several pairs of from and to .","title":"link.to"},{"location":"configuration/command/#env","text":"Type Required map no env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat'","title":"env"},{"location":"configuration/command/#alias","text":"Type Required map no alias allows you to set command aliases. Case 1 Case 2 Case 3 github : - name : colordiff description : Primary development for colordiff owner : daveewart repo : colordiff command : alias : diff : colordiff -u link : - from : colordiff.pl to : colordiff github : - name : exa description : A modern version of 'ls'. owner : ogham repo : exa release : name : exa tag : v0.9.0 command : alias : l : exa --group-directories-first -T --git-ignore --level 2 la : exa --group-directories-first -a --header --git ll : exa --group-directories-first -l --header --git lla : exa --group-directories-first -la --header --git ls : exa --group-directories-first link : - from : '*exa*' to : exa github : - name : bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat'","title":"alias"},{"location":"configuration/command/#snippet","text":"Type Required string no snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm snippet : | echo \"tpm is installed, so tmux will be automatically launched\" echo \"see github.com/tmux-plugins/tpm\"","title":"snippet"},{"location":"configuration/command/#if","text":"Type Required string no if allows you to specify the condition to load packages. If it returns true, then the command will be linked. But if it returns false, the command will not be linked. In if field, you can write shell scripts (currently bash is only supported). The exit code finally returned from that shell script is used to determine whether it links command or not. Case 1 link commands if git is installed github : - name : chmln/sd description : Intuitive find & replace CLI (sed alternative) owner : chmln repo : sd release : name : sd tag : 0.6.5 command : if : | type git &>/dev/null snippet : | replace() { case \"${#}\" in 1) git grep \"${1}\" ;; 2) git grep -l \"${1}\" | xargs -I% sd \"${1}\" \"${2}\" % ;; esac }","title":"if"},{"location":"configuration/plugin/","text":"Plugin # afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources. Parameters # sources # Type Required list yes sources allows you to select what to load files when starting shell. Case 1 Case 2 Case 3 Simple case, just register to init.sh as load scripts github : - name : enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh Using wildcards to register multiple files github : - name : zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme' Filenames starting with numbers local : - name : zsh directory : ~/.zsh plugin : sources : - '[0-9]*.zsh' env # Type Required list no env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme' snippet # Type Required string no snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh snippet : | echo \"enhancd is enabled, cd command is overrided by enhancd\" echo \"see github.com/b4b4r07/enhancd\" snippet-prepare (beta) # Type Required string no snippet-prepare allows you to specify the command which are runned when starting new shell. Unlike snippet , this snippet-prepare is run before source command. Run snippet-prepare Load sources Run snippet This option comes from #6 . Case 1 Run snippet before sources github : - name : sindresorhus/pure description : Pretty, minimal and fast ZSH prompt owner : sindresorhus repo : pure plugin : snippet-prepare : | zstyle :prompt:pure:git:branch color magenta zstyle :prompt:pure:git:branch:cached color yellow zstyle :prompt:pure:git:dirty color 091 zstyle :prompt:pure:user color blue zstyle :prompt:pure:host color blue sources : - pure.zsh if # Type Required string no if allows you to specify the condition to load packages. If it returns true, then the plugin will be loaded. But if it returns false, the plugin will not be loaded. In if field, you can write shell scripts (currently bash is only supported). The exit code finally returned from that shell script is used to determine whether it loads plugin or not. Case 1 if login shell is zsh, plugin will be loaded local : - name : zsh directory : ~/.zsh plugin : if : | [[ $SHELL == *zsh* ]] sources : - '[0-9]*.zsh'","title":"Plugin"},{"location":"configuration/plugin/#plugin","text":"afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources.","title":"Plugin"},{"location":"configuration/plugin/#parameters","text":"","title":"Parameters"},{"location":"configuration/plugin/#sources","text":"Type Required list yes sources allows you to select what to load files when starting shell. Case 1 Case 2 Case 3 Simple case, just register to init.sh as load scripts github : - name : enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh Using wildcards to register multiple files github : - name : zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme' Filenames starting with numbers local : - name : zsh directory : ~/.zsh plugin : sources : - '[0-9]*.zsh'","title":"sources"},{"location":"configuration/plugin/#env","text":"Type Required list no env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme'","title":"env"},{"location":"configuration/plugin/#snippet","text":"Type Required string no snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh snippet : | echo \"enhancd is enabled, cd command is overrided by enhancd\" echo \"see github.com/b4b4r07/enhancd\"","title":"snippet"},{"location":"configuration/plugin/#snippet-prepare-beta","text":"Type Required string no snippet-prepare allows you to specify the command which are runned when starting new shell. Unlike snippet , this snippet-prepare is run before source command. Run snippet-prepare Load sources Run snippet This option comes from #6 . Case 1 Run snippet before sources github : - name : sindresorhus/pure description : Pretty, minimal and fast ZSH prompt owner : sindresorhus repo : pure plugin : snippet-prepare : | zstyle :prompt:pure:git:branch color magenta zstyle :prompt:pure:git:branch:cached color yellow zstyle :prompt:pure:git:dirty color 091 zstyle :prompt:pure:user color blue zstyle :prompt:pure:host color blue sources : - pure.zsh","title":"snippet-prepare (beta)"},{"location":"configuration/plugin/#if","text":"Type Required string no if allows you to specify the condition to load packages. If it returns true, then the plugin will be loaded. But if it returns false, the plugin will not be loaded. In if field, you can write shell scripts (currently bash is only supported). The exit code finally returned from that shell script is used to determine whether it loads plugin or not. Case 1 if login shell is zsh, plugin will be loaded local : - name : zsh directory : ~/.zsh plugin : if : | [[ $SHELL == *zsh* ]] sources : - '[0-9]*.zsh'","title":"if"},{"location":"configuration/package/gist/","text":"Gist # Example # gist : - name : hoge.sh description : this is a test for gist owner : b4b4r07 id : f26dd264f094e0ca834ce9feadc0c3f1 command : link : - from : hoge.sh to : hoge Parameters # Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package owner string yes Gist owner id string yes Gist page id command section See Command page plugin section See Plugin page","title":"Gist"},{"location":"configuration/package/gist/#gist","text":"","title":"Gist"},{"location":"configuration/package/gist/#example","text":"gist : - name : hoge.sh description : this is a test for gist owner : b4b4r07 id : f26dd264f094e0ca834ce9feadc0c3f1 command : link : - from : hoge.sh to : hoge","title":"Example"},{"location":"configuration/package/gist/#parameters","text":"Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package owner string yes Gist owner id string yes Gist page id command section See Command page plugin section See Plugin page","title":"Parameters"},{"location":"configuration/package/github/","text":"GitHub # This github allows you to get GitHub repositories and releases. To get releases, you need to specify release field. Examples # Repository Release github : - name : kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns github : - name : jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq Parameters # Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package owner string yes GitHub owner repo string yes GitHub repo with.depth int no Fetch commit depth (default: 0). N>0 means shallow clone release.name string yes (in release ) GitHub release name release.tag string GitHub release tag command section See Command page plugin section See Plugin page","title":"GitHub"},{"location":"configuration/package/github/#github","text":"This github allows you to get GitHub repositories and releases. To get releases, you need to specify release field.","title":"GitHub"},{"location":"configuration/package/github/#examples","text":"Repository Release github : - name : kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns github : - name : jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq","title":"Examples"},{"location":"configuration/package/github/#parameters","text":"Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package owner string yes GitHub owner repo string yes GitHub repo with.depth int no Fetch commit depth (default: 0). N>0 means shallow clone release.name string yes (in release ) GitHub release name release.tag string GitHub release tag command section See Command page plugin section See Plugin page","title":"Parameters"},{"location":"configuration/package/http/","text":"HTTP # Example # http : - name : gcping description : Like gcping.com but a command line tool url : https://storage.googleapis.com/gcping-release/gcping_darwin_arm64_latest command : link : - from : gcping_* to : gcping Parameters # Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package url string yes URL which can be downloaded. output string TBD command section See Command page plugin section See Plugin page","title":"HTTP"},{"location":"configuration/package/http/#http","text":"","title":"HTTP"},{"location":"configuration/package/http/#example","text":"http : - name : gcping description : Like gcping.com but a command line tool url : https://storage.googleapis.com/gcping-release/gcping_darwin_arm64_latest command : link : - from : gcping_* to : gcping","title":"Example"},{"location":"configuration/package/http/#parameters","text":"Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package url string yes URL which can be downloaded. output string TBD command section See Command page plugin section See Plugin page","title":"Parameters"},{"location":"configuration/package/local/","text":"Local # Example # local : - name : zsh description : My zsh scripts directory : ~/.zsh plugin : sources : - '[0-9]*.zsh' - name : google-cloud-sdk description : Google Cloud SDK directory : ~/Downloads/google-cloud-sdk plugin : sources : - '*.zsh.inc' Parameters # Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package directory string yes Directory path where the target files are placed command section See Command page plugin section See Plugin page","title":"Local"},{"location":"configuration/package/local/#local","text":"","title":"Local"},{"location":"configuration/package/local/#example","text":"local : - name : zsh description : My zsh scripts directory : ~/.zsh plugin : sources : - '[0-9]*.zsh' - name : google-cloud-sdk description : Google Cloud SDK directory : ~/Downloads/google-cloud-sdk plugin : sources : - '*.zsh.inc'","title":"Example"},{"location":"configuration/package/local/#parameters","text":"Name Type Required Description name string yes Package name (must be unique in all packages) description string A description of a package directory string yes Directory path where the target files are placed command section See Command page plugin section See Plugin page","title":"Parameters"}]}